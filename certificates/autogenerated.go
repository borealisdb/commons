package certificates

import (
	"bytes"
	"crypto/rand"
	"crypto/rsa"
	"crypto/x509"
	"crypto/x509/pkix"
	"encoding/pem"
	"errors"
	"fmt"
	"github.com/sirupsen/logrus"
	"io/fs"
	"io/ioutil"
	"math/big"
	"os"
	"time"
)

const (
	Autogenerated = "autogenerated"

	certExt = "crt"
	keyExt  = "key"
)

type generatedKeyPairs struct {
	Cert []byte
	Key  []byte
}

type AutoGenerateStrategy struct {
	Log        *logrus.Entry
	Domain     string
	CommonName string
	BasePath   string
	generatedKeyPairs
}

func (c *AutoGenerateStrategy) Request(params RequestParams) (RequestResponse, error) {
	c.Log.Infof("requesting certificats")
	if c.exists() {
		isExpired, err := c.isExpired()
		if err != nil {
			return RequestResponse{}, err
		}
		if isExpired {
			c.Log.Infof("certificates exist, but are expired")
			if err := c.generate(); err != nil {
				return RequestResponse{}, err
			}

			return RequestResponse{}, nil
		}
		c.Log.Infof("certificates exist, skip generation")
		return RequestResponse{}, nil
	}
	c.Log.Infof("certificates do not exist")

	if err := c.generate(); err != nil {
		return RequestResponse{}, err
	}

	return RequestResponse{}, nil
}

func (c *AutoGenerateStrategy) generate() error {
	c.Log.Infof("generating certificates")
	certPrivateKey, err := rsa.GenerateKey(rand.Reader, 2048)
	if err != nil {
		c.Log.WithError(err).Fatal()
	}

	template := x509.Certificate{
		SerialNumber: big.NewInt(1),
		Subject: pkix.Name{
			CommonName: c.CommonName,
		},
		NotBefore: time.Now(),
		NotAfter:  time.Now().Add(time.Hour * 24 * 180),

		KeyUsage:              x509.KeyUsageKeyEncipherment | x509.KeyUsageDigitalSignature,
		ExtKeyUsage:           []x509.ExtKeyUsage{x509.ExtKeyUsageServerAuth},
		BasicConstraintsValid: true,
	}

	certBytes, err := x509.CreateCertificate(rand.Reader, &template, &template, &certPrivateKey.PublicKey, certPrivateKey)
	if err != nil {
		return err
	}

	certPEM := new(bytes.Buffer)
	if err := pem.Encode(certPEM, &pem.Block{
		Type:  "CERTIFICATE",
		Bytes: certBytes,
	}); err != nil {
		return err
	}

	certPrivateKeyPEM := new(bytes.Buffer)
	if err := pem.Encode(certPrivateKeyPEM, &pem.Block{
		Type:  "RSA PRIVATE KEY",
		Bytes: x509.MarshalPKCS1PrivateKey(certPrivateKey),
	}); err != nil {
		return err
	}
	c.Log.Infof("certificates have been generated")

	c.Cert = certPEM.Bytes()
	c.Key = certPrivateKeyPEM.Bytes()
	return nil
}

func (c *AutoGenerateStrategy) Deposit(params DepositParams) (DepositResponse, error) {
	c.Log.Infof("storing certificates")

	if c.exists() {
		return DepositResponse{}, nil
	}

	if err := os.MkdirAll(c.BasePath, fs.ModePerm); err != nil {
		return DepositResponse{}, err
	}

	certPath := c.getPath(certExt)
	keyPath := c.getPath(keyExt)

	if err := ioutil.WriteFile(certPath, c.Cert, fs.ModePerm); err != nil {
		return DepositResponse{}, err
	}
	if err := ioutil.WriteFile(keyPath, c.Key, fs.ModePerm); err != nil {
		return DepositResponse{}, err
	}

	c.Log.Infof("certificates stored at: %v, %v", certPath, keyPath)

	return DepositResponse{}, nil
}

func (c *AutoGenerateStrategy) GetLocations(params GetLocationParams) (Location, error) {
	return Location{
		CertPath: c.getPath(certExt),
		KeyPath:  c.getPath(keyExt),
	}, nil
}

func (c *AutoGenerateStrategy) isExpired() (bool, error) {
	c.Log.Infof("checking certifcates validity")
	rootPEM, err := ioutil.ReadFile(c.getPath(certExt))
	if err != nil {
		return false, err
	}

	roots := x509.NewCertPool()
	ok := roots.AppendCertsFromPEM(rootPEM)
	if !ok {
		return false, fmt.Errorf("failed to parse root certificate")
	}

	block, _ := pem.Decode(rootPEM)
	if block == nil {
		return false, fmt.Errorf("failed to parse certificate PEM")
	}
	cert, err := x509.ParseCertificate(block.Bytes)
	if err != nil {
		return false, fmt.Errorf("failed to parse certificate: %v", err)
	}

	opts := x509.VerifyOptions{
		DNSName:                   c.Domain,
		Intermediates:             nil,
		Roots:                     roots,
		CurrentTime:               time.Now(),
		KeyUsages:                 nil,
		MaxConstraintComparisions: 0,
	}

	if _, err := cert.Verify(opts); err != nil {
		if invalidError, ok := err.(x509.CertificateInvalidError); ok {
			if invalidError.Reason == x509.Expired {
				c.Log.Infof("certificates are expired %v", invalidError.Detail)
				return true, nil
			}

			return true, fmt.Errorf("certificate are not valid. Reason: %v", invalidError.Reason)
		}
		return false, fmt.Errorf("failed to verify certificate: %v", err)
	}

	return false, nil
}

func (c *AutoGenerateStrategy) exists() bool {
	certPath := c.getPath(certExt)
	keyPath := c.getPath(keyExt)
	if _, err := os.Stat(certPath); errors.Is(err, os.ErrNotExist) {
		return false
	}
	if _, err := os.Stat(keyPath); errors.Is(err, os.ErrNotExist) {
		return false
	}
	return true
}

func (c *AutoGenerateStrategy) getPath(extension string) string {
	return fmt.Sprintf("%s/%s.%s", c.BasePath, c.Domain, extension)
}
